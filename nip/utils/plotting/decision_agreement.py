"""Utilities for computing to what extent the datapoint decisions of rollouts agree."""

from dataclasses import dataclass

import numpy as np
from numpy.ma import masked_array
from numpy.typing import NDArray

from tqdm import tqdm

from nip.utils.nested_array_dict import NestedArrayDict
from nip.utils.plotting.rollouts import get_last_timestep_mask


@dataclass
class DecisionAgreementAnalysis:
    """Class for storing the results of a decision agreement analysis.

    Parameters
    ----------
    matrix : NDArray
        A matrix of shape (n_rollouts, n_rollouts), which for each pair of rollouts
        contains the proportion of the datapoints for which the verifier makes the same
        decision.
    positive_matrix : NDArray
        A matrix of shape (n_rollouts, n_rollouts), which for each pair of rollouts
        contains the proportion of the positively labelled datapoints for which the
        verifier makes the same decision.
    negative_matrix : NDArray
        A matrix of shape (n_rollouts, n_rollouts), which for each pair of rollouts
        contains the proportion of the negatively labelled datapoints for which the
        verifier makes the same decision.
    """

    matrix: NDArray
    positive_matrix: NDArray
    negative_matrix: NDArray


def analyse_decision_agreement(
    rollouts: list[NestedArrayDict], use_tqdm: bool = True
) -> DecisionAgreementAnalysis:
    """Analyse to what extent the datapoint decisions of rollouts agree.

    This function computes various statistics about to what extent the verifiers in the
    rollouts agree on the decisions they make for the datapoints.

    Notes
    -----
    - This function currently only works for rollouts generated by pure-text trainers,
      where rollouts are stored in a :class:`NestedArrayDict
      <nip.utils.nested_array_dict.NestedArrayDict>`.
    - The function assumes that the rollouts all have the same datapoints (but not
      necessarily in the same order). It will raise an error if the datapoint IDs are
      not the same across all rollouts.

    Parameters
    ----------
    rollouts : list[NestedArrayDict]
        The rollouts to be analysed. Each rollout is a NestedArrayDict containing the
        datapoints and their corresponding decisions.
    use_tqdm : bool, default=True
        Whether to use tqdm to show a progress bar.

    Returns
    -------
    DecisionAgreementAnalysis
        An object containing the results of the analysis.

    Raises
    ------
    ValueError
        If the rollouts do not have the same datapoint IDs in the same order.
    """

    # Sort each set of rollouts by the datapoint IDs
    rollouts = [
        rollout_set[np.argsort(rollout_set["datapoint_id"][:, 0])]
        for rollout_set in rollouts
    ]

    # Check that all rollouts have the same datapoint IDs
    first_rollout_datapoint_ids = rollouts[0]["datapoint_id"][:, 0]
    for rollout in rollouts[1:]:
        if not np.all(rollout["datapoint_id"][:, 0] == first_rollout_datapoint_ids):
            raise ValueError(
                "The rollouts do not have the same datapoint IDs in the same order."
            )

    num_rollouts = len(rollouts)
    decision_agreement_matrix = np.zeros((num_rollouts, num_rollouts))
    decision_agreement_positive_matrix = np.zeros((num_rollouts, num_rollouts))
    decision_agreement_negative_matrix = np.zeros((num_rollouts, num_rollouts))

    num_pairs = num_rollouts * (num_rollouts - 1) / 2

    p_bar = tqdm(
        total=num_pairs,
        desc="Computing decision agreement",
        disable=not use_tqdm,
    )

    for i, first_rollout_set in enumerate(rollouts):
        for j, second_rollout_set in enumerate(rollouts):
            if i >= j:
                continue

            y = first_rollout_set["y"][..., -1]

            # Get the verifier decisions for each rollout
            first_decision = first_rollout_set["agents", "decision"][..., -1]
            first_decision = first_decision[get_last_timestep_mask(first_rollout_set)]
            second_decision = second_rollout_set["agents", "decision"][..., -1]
            second_decision = second_decision[
                get_last_timestep_mask(second_rollout_set)
            ]

            agreement = first_decision == second_decision

            decision_agreement_matrix[i, j] = np.mean(agreement)
            decision_agreement_positive_matrix[i, j] = masked_array(
                agreement, mask=(y != 1)
            ).mean()
            decision_agreement_negative_matrix[i, j] = masked_array(
                agreement, mask=(y != 0)
            ).mean()

            p_bar.update(1)

    p_bar.close()

    # Fill in the lower triangle of the matrices
    decision_agreement_matrix += decision_agreement_matrix.T
    decision_agreement_positive_matrix += decision_agreement_positive_matrix.T
    decision_agreement_negative_matrix += decision_agreement_negative_matrix.T

    # Set the diagonal to 1
    np.fill_diagonal(decision_agreement_matrix, 1)
    np.fill_diagonal(decision_agreement_positive_matrix, 1)
    np.fill_diagonal(decision_agreement_negative_matrix, 1)

    return DecisionAgreementAnalysis(
        matrix=decision_agreement_matrix,
        positive_matrix=decision_agreement_positive_matrix,
        negative_matrix=decision_agreement_negative_matrix,
    )
